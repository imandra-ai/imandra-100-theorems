(* A proof of the denumerability of the rationals in Imandra.
   Theorem 3 in the 100 Theorems list. 

   Grant Passmore, Imandra
 *)

[@@@import "sqrt2_irrational.iml"]

module Rational = Sqrt2_irrational.Rational

module Bijection = struct

  let surj f g dom codom y =
    codom y ==> f (g y) = y && dom (g y)
  
  let inj f g dom codom x =
    dom x ==> g (f x) = x && codom (f x)
  
  let top (f : 'a -> 'b)
          (g : 'b -> 'a)
          (dom : 'a -> bool)
          (codom : 'b -> bool)
          (x : 'a)
          (y : 'b)
    =
    surj f g dom codom y
    && inj f g dom codom x
  
end

(* Cantor's pairing function and a proof it's a bijection from NxN to N *)

module Cantor = struct

  let rec sum n =
    if n <= 0 then 0
    else n + sum (n-1)

  lemma sum_psd n = 
    sum n >= 0 
  [@@by auto] [@@fc]

  lemma sum_bound n =
   sum n >= n 
  [@@by auto] [@@fc]

  let rec sum_inverse m x =
  if x <= 0 then
    0
  else if (m >= sum x) then
    x
  else sum_inverse m (x-1)

  lemma sum_inv_is_inv_of_sum_helper y p =
    (sum y) < sum (p+1) && p <= y
      ==>
      ((y = p) = true)
  [@@by induct ~on_fun:[%id sum] ()] [@@rw]

  lemma sum_inv_is_inv_sum i y p =
    i >= 0 && y >= 0 && p >= 0 &&
    p <= y && i <= p
      ==>
    sum_inverse (i + sum p) y = p
  [@@by auto]

  lemma sum_inv_sum_corollary i p =
    i >= 0 && p >= 0 && i <= p
      ==>
      sum_inverse (i + sum p) (i + sum p) = p
  [@@by [%use sum_inv_is_inv_sum i (i + sum p) p]
     @> auto] [@@rw]

  lemma helper n y x =
   y >= n
   ==>
   y <= 0
   || n >= y + sum x
   || (sum (sum_inverse n x)) <= n
   || y >= 1 + n
  [@@by auto]

  lemma helper_2 n u = 
    sum (sum_inverse n (-1 + u)) <= n
    ==>
    sum (sum_inverse n u) <= n
  [@@by auto] [@@fc]

  lemma sum_sum_inv_bound_1 n y =
    n >= 0 && y >= 0 && y >= n
      ==>
    (sum ((sum_inverse n y))) [@trigger] <= n
  [@@by [%use helper n y (y-1)] @> auto]
  [@@fc] [@@rw]

  lemma sum_sum_inv_bound_2 n y =
    n >= 0 && y >= 0 && sum y >= n
      ==>
   sum ((sum_inverse n y)) >= n - sum_inverse n y
  [@@by auto]

  let cantor_pair (a,b) =
      b + sum (a+b)

  let cantor_pair_inverse n =
      if n = 0 then (0,0)
      else
        let j = n - sum (sum_inverse n n) in
        let i = sum_inverse n n - j in
        (i, j)
      
  (* Main theorem I: Cantor pairing is a surjection from N x N -> N *)

  theorem cantor_pair_onto n =
    let (a, b) = cantor_pair_inverse n in
    n >= 0
      ==>
    a >= 0 && b >= 0 && cantor_pair (a, b) = n
  [@@by [%use sum_sum_inv_bound_2 n n]
     @> auto] 

  lemma cantor_pair_is_inverse a b =
     a >= 0 && b >= 0
       ==>
     cantor_pair_inverse (cantor_pair (a,b)) = (a,b)
  [@@by auto] 

  (* Main theorem II: Cantor pairing is an injection from N x N -> N *)

  theorem cantor_pair_one_one a b a' b' =
    a >= 0 && b >= 0 && a' >= 0 && b' >= 0
    && cantor_pair (a,b) = cantor_pair (a',b')
      ==>
    a = a' && b = b'
  [@@by [%use cantor_pair_is_inverse a b]
    @>  [%use cantor_pair_is_inverse a' b']
    @> auto]
  [@@disable cantor_pair]

  theorem bijection (n : int) (p : int * int) =
     Bijection.top
       cantor_pair
       cantor_pair_inverse
       (fun (a,b) -> a >= 0 && b >= 0)
       (fun n -> n >= 0)
       p
       n
  [@@by [%use cantor_pair_onto n]
     @> [%use cantor_pair_is_inverse (fst p) (snd p)]
     @> auto]

end

(* Now, let's lift the Cantor bijection from N x N to Q *)

let neg_bit n = if n < 0 then 1 else 0

lemma neg_bit_psd n = neg_bit n >= 0

let sign b k = if b=1 then (0-k) else k

let encode_terms (q:Rational.t) =
    let n1,n2,n3,n4 =
      neg_bit q.num,
      abs q.num,
      neg_bit q.den,
      abs q.den in
    n1,n2,n3,n4

lemma encode_terms_psd q =
  let n1,n2,n3,n4 = encode_terms q in
  n1 >= 0
  && n2 >= 0
  && n3 >= 0
  && n4 >= 0
[@@by auto]

let encode (q:Rational.t) : int =
  let n1,n2,n3,n4 = encode_terms q in
  let f = Cantor.cantor_pair
in
f (n1, f (n2, f (n3, n4)))

lemma cantor_pair_psd a b =
  a >= 0 && b >= 0 ==> Cantor.cantor_pair (a,b) >= 0
[@@by auto] [@@fc]

lemma sign_neg_abs x =
  (if ((if x < 0 then 1 else 0) = 1) then 0 - abs x else abs x) = x
[@@by unroll 0]

lemma encode_psd q = 
  encode q >= 0
[@@by auto] [@@fc]

let decode (n:int) : Rational.t =
  let g = Cantor.cantor_pair_inverse in
  let n1,n = g n in
  let n2,n = g n in
  let n3,n4 = g n
in
{ Rational.num = sign n1 n2;
  Rational.den = sign n3 n4 }

lemma abs_psd n =
  abs n >= 0
[@@by auto]

lemma sign_neg_abs x =
  (let b = (if x < 0 then 1 else 0) in
   let k = abs x in
   (if b = 1 then (0 - k) else k)) = x
[@@by auto]

(* Our main theorem: The rationals are denumerable! *)

theorem decode_onto (q:Rational.t) =
  decode (encode q) = q
[@@by
  [%expand decode (encode q)]
  @> let n1,n2,n3,n4 = encode_terms q in
  (* all four components are >= 0 *)
  [%use encode_terms_psd q]
  (* build up the nonnegativity needed for nesting *)
  @> [%use cantor_pair_psd n3 n4]
  @> [%use cantor_pair_psd n2 (Cantor.cantor_pair (n3, n4))]
  @> [%use cantor_pair_psd n1 (Cantor.cantor_pair (n2, Cantor.cantor_pair (n3, n4)))]
  (* now use the Cantor pairing inverses *)
  @> [%use Cantor.cantor_pair_is_inverse n3 n4]
  @> [%use Cantor.cantor_pair_is_inverse n2 (Cantor.cantor_pair (n3, n4))]
  @> [%use Cantor.cantor_pair_is_inverse n1 (Cantor.cantor_pair (n2, Cantor.cantor_pair (n3, n4)))]
  (* a little arithmetic, and boom! *)
  @> lift_ifs
  @> [%use sign_neg_abs q.Rational.num]
  @> [%use sign_neg_abs q.Rational.den]
  @> auto
]
[@@disable Cantor.cantor_pair, Cantor.cantor_pair_inverse, neg_bit, sign]

(* Main Theorem (surjection packaged): decode : ℕ ↠ Q *)

theorem rationals_denumerable_surj (q : Rational.t) =
  Bijection.surj
    decode
    encode
    (fun n -> n >= 0)  (* dom on N *)
    (fun (_:Rational.t) -> true)  (* all rationals allowed *)
    q
[@@by
  [%use decode_onto q]   (* decode (encode q) = q *)
  @> [%use encode_psd q] (* encode q >= 0         *)
  @> auto
]
[@@disable encode, decode]